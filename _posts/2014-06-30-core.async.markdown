h1. Les bons tuyaux de core.async

[Clojure](http://clojure.org) est le langage le plus simple et le plus cohérent que je connaisse. Le coeur du langage est très concis et fournit pourtant tous les outils nécessaires à l'écriture efficace de programmes modernes (manipulation de données, multithreading).

[core.async](https://github.com/clojure/core.async) est une librairie qui introduit un nouvel outil très simple conceptuellement qui offre des possibilités incroyables. Elle fait partie du projet clojure mais est facultative.


h2. Channels


L'élément central de core.async est le _channel_.
Il s'agit d'un tuyau, d'un canal, similaire à une _queue_ dans [AMQP](http://www.arolla.fr/blog/2012/11/amqp-101-part-1/).

Un _channel_ se crée simplement

        (chan)


Un tel _channel_ est non bufferisé. Cela signifie que l'écriture dans ce _channel_ est bloquée tant que personne ne lit la valeur présente.

Un _channel_ peut être bufferisé et est créé avec la fonction `chan`. Ici on crée un _channel_ qui ne peut bufferiser qu'une seule valeur:

        (chan 1)

Un tel _channel_ permet d'écrire consécutivement 2 valeurs sans que personne ne lise la valeur.

Je conseille de travailler avec des _channel_s non bufferisés dans un premier temps. Cela rend le raisonnement et la compréhension du code plus aisés.


Un _channel_ est une valeur comme une autre. Ici on l'associe à une (Var)[http://clojure.org/vars] :

        (def player1 (chan 1))

On pourra donc associer le _channel_ `player1` dans une `Map` par exemple, ou si on est vicieux, le faire transiter dans un autre _channel_.


h2. Invertion Of Control

On part d'un _channel_ non bufferisé :

        (def player1 (chan))

Pour écrire dans un channel, on utilise la fonction bloquante `>!!`

        (>!! player1 [5 8])

A ce stade, `player1` contient le vecteur `[5 8]`. Par contre l'exécution du programme est bloquée jusqu'à ce que la valeur du _channel_ soit lue. Il existe bien une opération de lecture `<!!`, mais puisqu'on est bloqué, elle ne sera jamais exécutée. Comment faire ?

La solution est d'effectuer l'opération de lecture dans une autre unité d'exécution, soit un thread.

        (thread
          (loop [m "player 1 moves : "]
            (println "Player 1 just thows " )
            (recur (<!! player1))))


La macro thread permet de créer ... un thread. Ce thread boucle indéfiniment. A chaque itération de boucle il affiche la valeur
contenue dans le _channel_ `player1`. Et dans un REPL ça donne :

    user=> (def player1 (chan))
    #'user/player1

    user=> (thread (loop [m "player 1 moves : "] (println m) (recur (<!! player1))))
    player 1 moves
    #<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@34451e6>

    user=> (>!! player1 [5 8])
    true
    [5 8]

    user=> (>!! player1 [1 2])
    [1 2]
    true

    user=> (>!! player1 [1 3])
    [1 3]
    true


On a un thread qui produit les mouvements du joueur 1 sans savoir ce qui en sera fait. Et on a un autre thread qui reçoit les mouvements et les affiche. Au runtime nous avons nous même fait l'association producteur / consommateur. Cela correspond à la notion d'[Invertion of Control](http://martinfowler.com/bliki/InversionOfControl.html), si ce n'est qu'on a codé notre propre framework et utilisant un _channel_ pour faire la colle entre les composants.

L'IoC est assez naturelle dans les langages fonctionnels puisqu'on peut passer des fonctions en paramètre (fonctions de 1er ordre) :

    (defn print-claim [m] (print m))

    (defn player-claim [fingers sum handler]
      (handler [fingers sum]))

    (player-claim 5 8 print-claim)

Ceci affiche 5 8 dans la console.

La version du code utilisant `core.async` va plus loin en rendant le code asynchrone. A chaque composant sa spécialisation, à chaque composant son unité d'exécution.

h2. Modèle d'acteur

[Wikipedia](http://fr.wikipedia.org/wiki/Mod%C3%A8le_d%27acteur) définit le modèle d'acteur ainsi :

    Un acteur est une entité capable de calculer, qui, en réponse à un message reçu, peut parallèlement :

      - envoyer un nombre fini de messages à d’autres acteurs ;
      - créer un nombre fini de nouveaux acteurs ;
      - spécifier le comportement à avoir lors de la prochaine réception de messages.

    L’exécution des tâches ci-dessus n’est pas ordonnée, elles peuvent être parallélisées.


Etudions ce petit programme :

    (def player1 (chan))
    (def player2 (chan))
    (def result (chan))


    (thread
     (loop [scores {:player1 0 :player2 0 :draw 0}]
       (println "Scores : " scores)
       (recur
        (update-in scores [(<!! result)] inc))))

    (defn winner [correct-guess p1-guess p2-guess]
      (cond
       (= p1-guess p2-guess) :draw
       (= correct-guess p1-guess) :player1
       (= correct-guess p2-guess) :player2
       :else :draw))

    (thread
     (loop []
       (let [[p1-fingers p1-guess] (<!! player1)
             [p2-fingers p2-guess] (<!! player2)
             correct-guess (+ p1-fingers p2-fingers)]
         (>!! result (winner correct-guess p1-guess p2-guess))
         (recur))))

On a 2 unités d'exécution. La première est dédiée à l'affichage du score. A chaque fois qu'une valeur est présente dans `result` la valeur de `scores` est mise à jour.

Notons que la valeur `scores` est complètement *encapsulée*. Personne d'autre ne peut connaitre le score.

Au prochain appel l'une des 3 valeur de la map sera incrémentée. Le 3ème point, _spécifier le comportement à avoir lors de la prochaine réception de messages_, est vérifié.

La seconde unité d'exécution lit tour à tour dans les _channel_s `player1` et `player2`, détermine un gagnant et écrit le résultat dans `result` qui sera relue par notre 1ère unité d'exécution. Le 1er point, _envoyer un nombre fini de messages à d’autres acteurs_ est vrai.

Concernant la deuxième proposition, _créer un nombre fini de nouveaux acteurs_, je n'ai pas trouvé quelque chose de pertinant pour le démontrer. Cela est néanmoins possible si on remplace le premier acteur par ceci :

    (defn print-stats [stats]
      (let [total (apply + (vals stats))]
        (println "wins : " (:wins stats) "/" total)
        (println "draws : " (:draws stats) "/" total)))

    (defn run-stats [channel]
      (loop [stats {:wins 0, :draws 0}
             total 0]
          (print-stats stats)
          (recur
           (update-in stats [(<!! channel)] inc)
           (inc total))))

    (thread

     (let [stats (chan)]

       (thread (run-stats stats))

       (loop [scores {:player1 0 :player2 0 :draw 0}]
         (println "Scores : " scores)
         (let [winner (<!! result)]
           (>!! stats (if (= :draw winner) :draw :wins))
           (recur (update-in scores [winner] inc))))))

La présence des deux threads imbriqués indique le lancement d'un acteur par un autre.

h2. Programmation concurrente illimitée

Dans les précédents exemples nous avons instancié des threads pour consommer les valeurs contenues dans les _channels_. Chacun de ces threads consistait en une boucle infinie qui bloquait sont exécution jusqu'à ce qu'une valeur soit lisible. Ce modèle est limité par les [quelques milliers](http://stackoverflow.com/questions/763579/how-many-threads-can-a-java-vm-support) de threads que l'on peut lancer sur la VM. Sans compter [le temps perdu](http://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html) en [context switch](http://en.wikipedia.org/wiki/Context_switch).

Imaginons maintenant que notre plateforme de jeu n'ai pas quelques milliers de threads mais plutôt un centaine de millier.

    (dotimes [t 100000]
      (let [c (chan)]
        (thread
         (loop []
           (let [[_ v :as tv] (<!! c)]
             (if (= 0 (mod v 100)) (println tv)))
           (recur)))
        (thread
         (doseq [v (iterate inc 1)]
           (>!! c [t v])))))

Ici on crée 2 threads 100000 fois. Le premier lit dans un channel et affiche le résultat si c'est un multiple de 100. Le second écrit les entiers de 1 à l'infini.

10000 lignes environ s'affichent puis plus rien. Le CPU monte à 100%, la JVM compte 32000 threads et boom, IOException.


Pour pallier à ces limitations, _core.async_ offre la possibilité de créer des processus ultra légers, capables de se partager un pool de threads et qui peuvent se mettre en pause sans bloquer le thread d'exécution.

    (dotimes [t 100000]
      (let [c (chan)]
        (go
         (loop []
           (let [[t v :as tv] (<! c)]
             (if (= 0 (mod v 100)) (println tv)))
           (recur)))
        (go
         (doseq [v (iterate inc 1)]
           (>! c [t v])))))

Dans cette version du programme, j'ai remplacé les threads créés par `thread` par des processus ultra légers via `go` et les appels bloquants `>!!` et `<!!` par leurs versions non-bloquantes `>!` et `<!`. Le programme est stable et régulier : des salves d'informations s'affichent sur la console toutes les 40 secondes environ, les 8 coeurs de mon CPU sont à 40%, la consommation du heap oscille entre 1700 mégas et 160 après GC, et la JVM compte 70 threads.

Nous avons donc réussi à *simuler* 200000 threads ! Ne vous réjouissez pas si vite, j'ai oublié de préciser que ce code tourne aussi sur un navigateur ... Oui on peut écrire du code asynchrone dans le navigateur sans callbacks (hell).

Cela me fait drôlement penser au modèle de [Vert.x](http://vertx.io).

h2. Functional Reactive Programming

Dans un article précédent, j'avais fait une micro présentation de FRP. Pour rappel, il s'agit d'un style de programmation basé sur la manipulation de flux de valeurs, à base de `map`, `filter`, `zip`, `concat`, ...  En bout de chaine de chaque flux, on peut "consommer" les valeurs du flux pour réaliser des effets de bord, un affichage ou une écriture en base par exemple.



le truc du haut c'est bien mais ordre + timeout


h2. Les mots de la fin

Encore une fois, je suis subjugué par la puissante simplicité de Clojure. `core.async`, en terme d'API, c'est juste un tuyau et des processus pour y lire et écrire. Cet outil simplissime dans son utilisation offre d'énorme possibilités. Comme nous l'avons vu, ce n'est pas un framework mais une librairie qui permet de faire du *sur mesure* pour nos besoins d'IOC, acteur, concurrence, FRP, ...

h2. Ressources

[Rationale](http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html) : explication des concepts fondamentaux et leur origine.

[Walk throught](https://github.com/clojure/core.async/blob/master/examples/walkthrough.clj) Des exemples à taper dans la REPL.

[Le jeu de Morra](http://en.wikipedia.org/wiki/Morra_%28game%29) : le petit jeu implémenté dans cet article. é"



