I"Â;<h1 id="comment-fonctionne-un-debugger-">Comment fonctionne un debugger ?</h1>

<div id="toc-js">
</div>

<h2 id="motivations">Motivations</h2>

<p>Un debugger est un outil fabuleux : cette sensation de contr√¥le divin ! La possibilit√© de figer l‚Äôex√©cution d‚Äôun process et d‚Äôinspecter les arcanes de sa m√©moire.</p>

<p>C‚Äô√©tait les deux phrases lyriques de cet article :) Nous verrons que le divin n‚Äôest qu‚Äôune machinerie bien huil√©e.</p>

<p>Le d√©bugger est un outil que j‚Äôutilise quotidiennement. Je trouve important d‚Äôen comprendre les m√©canismes sous-jacents. Ecrire un concurrent √† <a href="https://en.wikipedia.org/wiki/GNU_Debugger">GDB</a> n‚Äôest certainement pas la meilleur fa√ßon d‚Äôutiliser son temps libre. En revanche √©crire un
<a href="https://en.wikipedia.org/wiki/Proof_of_concept">POC</a> de d√©bugger est certainement la mani√®re la plus didactique d‚Äôapprendre ! Et c‚Äôest ce que je vous propose aujourd‚Äôhui, d‚Äô√©crire un petit debugger pas super pratique mais fonctionnel.</p>

<p>Concernant le fond, cet article ne traite que de Linux sous architecture x86_64. Il part du principe que vous avez de vagues notions sur ce qu‚Äôest :</p>

<ul>
  <li>l‚Äô<a href="https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture">architecture x86</a></li>
  <li>le langage <a href="https://en.wikipedia.org/wiki/X86_instruction_listings">assembleur x86</a></li>
  <li>le syst√®me Linux</li>
  <li>un <a href="https://en.wikipedia.org/wiki/Process_%28computing%29">process</a></li>
  <li>un <a href="https://en.wikipedia.org/wiki/Unix_signal">signal Unix</a></li>
  <li>le langage C</li>
</ul>

<p>Concernant la forme, cet article est en franglish (parce que je trouve √©trange d‚Äô√©crire <em>deboggueur</em>). Les exemples sont en langage C et ils ne sont sp√©cifiques √† l‚Äôarchitecture x86_64 (ne fonctionneront pas en 32 bits). N‚Äô√©tant pas codeur C, il y a certainement plein de choses √† redire sur mon code, n‚Äôh√©sitez pas √† le faire.</p>

<p>Pour toute question, n‚Äôh√©sitez pas √† me contacter.</p>

<h2 id="rapide-rappel-sur-les-syscalls-et-les-interruptions">Rapide rappel sur les syscalls et les interruptions</h2>

<p>Si vous savez d√©j√† ce qu‚Äôest un syscall, vous pouvez sauter cette section.</p>

<p>Le processeur a plusieurs niveaux d‚Äôex√©cution :</p>

<ul>
  <li>
    <p>Typiquement le noyau Linux tourne dans un mode dit <em>privil√©gi√©</em>. Dans ce mode il peut acc√®der √† toute la m√©moire, lire et √©crire sur disque, ‚Ä¶</p>
  </li>
  <li>
    <p>Les autres process, comme votre navigateur, tournent dans un mode <em>non privil√©gi√©</em>. Ils n‚Äôont acc√®s qu‚Äô√† une certaine partie de la m√©moire et ne peuvent pas √©crire directement sur disque.</p>
  </li>
</ul>

<p>Tant qu‚Äôun process se contente de faire des calculs et de lire et √©crire en m√©moire, il est autonome. Mais d√®s qu‚Äôil d√©cide d‚Äôagir sur son environnement (a.k.a. <em>side effect</em>), comme √©crire sur le disque, il doit utiliser un <em>appel syst√®me</em> a.k.a <em>syscall</em>.</p>

<p>Le process effectuant un <em>syscall</em> donne la main au noyau et <strong><em>bloque</em></strong> jusqu‚Äô√† ce que le <em>syscall</em> ait √©t√© effectu√©. Un <em>syscall</em> est en g√©n√©ral une op√©ration co√ªteuse en temps.</p>

<p>Linux impl√©mente le standard <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a> qui d√©finit un ensemble d‚Äôappels syst√®me.</p>

<p>En voici un extrait :</p>

<table>
  <thead>
    <tr>
      <th>%rax</th>
      <th>syscall</th>
      <th>%rdi</th>
      <th>%rsi</th>
      <th>%rdx</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>read</td>
      <td><code class="highlighter-rouge">unsigned int file_descriptor</code></td>
      <td><code class="highlighter-rouge">char * buffer</code></td>
      <td><code class="highlighter-rouge">size_t length</code></td>
    </tr>
    <tr>
      <td>1</td>
      <td>write</td>
      <td><code class="highlighter-rouge">unsigned int file_descriptor</code></td>
      <td><code class="highlighter-rouge">char * buffer</code></td>
      <td><code class="highlighter-rouge">size_t length</code></td>
    </tr>
    <tr>
      <td>57</td>
      <td>fork</td>
      <td>¬†</td>
      <td>¬†</td>
      <td>¬†</td>
    </tr>
    <tr>
      <td>59</td>
      <td>execve</td>
      <td><code class="highlighter-rouge">const char *filename</code></td>
      <td><code class="highlighter-rouge">const char *const argv[]</code></td>
      <td><code class="highlighter-rouge">const char *const envp[]</code></td>
    </tr>
    <tr>
      <td>60</td>
      <td>exit</td>
      <td><code class="highlighter-rouge">int error_code</code></td>
      <td>¬†</td>
      <td>¬†</td>
    </tr>
    <tr>
      <td>62</td>
      <td>kill</td>
      <td><code class="highlighter-rouge">pid_t pid</code></td>
      <td><code class="highlighter-rouge">int signal</code></td>
      <td>¬†</td>
    </tr>
    <tr>
      <td>101</td>
      <td>ptrace</td>
      <td><code class="highlighter-rouge">long request</code></td>
      <td><code class="highlighter-rouge">long pid</code></td>
      <td><code class="highlighter-rouge">unsigned long data</code></td>
    </tr>
  </tbody>
</table>

<p>Allez voir la <a href="http://blog.rchapman.org/post/36801038863/linux-system-call-table-for-x86-64">liste compl√®te</a>.</p>

<p>Chaque <em>syscall</em> a un identifiant qui est plac√© dans le registre <code class="highlighter-rouge">RAX</code> et peut avoir jusqu‚Äô√† 6 param√®tres pass√©s par convention dans les registres <code class="highlighter-rouge">RDI</code>, <code class="highlighter-rouge">RSI</code>, <code class="highlighter-rouge">RDX</code>, <code class="highlighter-rouge">RCX</code>, <code class="highlighter-rouge">R8</code>, <code class="highlighter-rouge">R9</code>.</p>

<p><code class="highlighter-rouge">read</code> et <code class="highlighter-rouge">write</code> permettent de lire et d‚Äô√©crire dans un fichier. Nous aborderons les autres un peu plus tard.</p>

<p>L‚Äôexemple suivant est un typique ‚Äúhello world‚Äù qui illustre un appel au  <em>syscall</em> <code class="highlighter-rouge">write</code> :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0x1</span><span class="p">,</span><span class="o">%</span><span class="nb">rax</span>
<span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0x1</span><span class="p">,</span><span class="o">%</span><span class="nb">rdi</span>
<span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0x4000fe</span><span class="p">,</span><span class="o">%</span><span class="nb">rsi</span>
<span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0xd</span><span class="p">,</span><span class="o">%</span><span class="nb">rdx</span>
<span class="nf">syscall</span>
</code></pre></div></div>

<p>Traduit en fran√ßais, cela donne : ‚ÄúAppel du syscall <code class="highlighter-rouge">sys_write</code> (RAX=1) pour √©crire dans le file descriptor 1 (RDI=1), alias la sortie standard, la cha√Æne de caract√®re √† l‚Äôadresse 0x4000fe (RSI=0x4000fe) de longueur 13 (RDX=0xd). Notez l‚Äôinstruction <code class="highlighter-rouge">syscall</code> qui est une vraie instruction assembleur x86_64.</p>

<p>Il existe un utilitaire tr√®s pratique, <code class="highlighter-rouge">strace</code>, qui permet de tracer tous les <em>syscall</em> effectu√©s par un process. Par exemple pour tracer tous les <em>syscall</em> <code class="highlighter-rouge">write</code> de la commande <code class="highlighter-rouge">echo</code> :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$strace</span> <span class="nt">-o</span> <span class="s1">'| grep write'</span> <span class="nb">echo</span> <span class="s2">"Hello"</span>
write<span class="o">(</span>1, <span class="s2">"Hello</span><span class="se">\n</span><span class="s2">"</span>, 6<span class="o">)</span>                  <span class="o">=</span> 6
</code></pre></div></div>

<ul>
  <li>On √©crit dans le file descriptor 1 (sortie standard),</li>
  <li>Une chaine de caract√®re qui contient ‚ÄúHello\n‚Äù</li>
  <li>On √©crit 6 caract√®res</li>
  <li><code class="highlighter-rouge">write</code> a bien √©crit 6 caract√®res</li>
</ul>

<p>Un process pr√©pare les param√®tres du <em>syscall</em> dans les registres du CPU et fait ex√©cuter l‚Äôinstruction <code class="highlighter-rouge">syscall</code> au CPU. Et l√† magiquement l‚Äôex√©cution du process s‚Äôarr√™te (bloque) et ne reprend que lorsque le <em>syscall</em> a √©t√© r√©alis√©.</p>

<p>La tuyauterie permettant cela s‚Äôappelle une <em>interruption</em>. Une <em>interruption</em> permet au CPU d‚Äôappeler une fonction du kernel. Donc quand le CPU ex√©cute l‚Äôinstruction <code class="highlighter-rouge">syscall</code>, il redonne la main au noyau qui se d√©brouille pour mettre en pause le process appelant, ex√©cuter la commande <em>syscall</em> demand√©e avec les param√®tres, et relancer le process.</p>

<h2 id="salut-fiston-cest-papa-">Salut fiston, c‚Äôest papa !</h2>

<p>Si vous savez d√©j√† ce qu‚Äôest un <code class="highlighter-rouge">fork</code>, vous pouvez sauter cette section.</p>

<p>On peut imaginer qu‚Äôun debugger a une certaine emprise sur le process d√©bogg√©. Sous Linux, ce genre d‚Äôabus de position s‚Äôexprime par une relation p√®re fils.</p>

<p>Si vous avez une console √† proximit√© et que vous tapez <code class="highlighter-rouge">pstree</code> vous remarquerez que les process sont organis√©s hi√©rarchiquement. La racine commune √† tous est <code class="highlighter-rouge">systemd</code> (ou <code class="highlighter-rouge">init</code> sur des syst√®mes plus anciens) et votre navigateur est une feuille de l‚Äôarbre.</p>

<p>Pour cr√©er un process fils, un futur p√®re utilise le syscall <code class="highlighter-rouge">fork</code>. C‚Äôest d‚Äôailleurs la seule fa√ßon de cr√©er des process. Voici un code typique :</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>   <span class="n">pid_t</span> <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"I am the child"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"I am the father of %d"</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">fork</code> proc√®de √† une copie presque int√©grale du processus appelant (m√©moire, registres CPU, ‚Ä¶). L‚Äôappelant devient le processus p√®re du clone qui est donc son fils.
Quand <code class="highlighter-rouge">fork</code> rend la main, les 2 processus continuent leurs ex√©cution juste apr√®s l‚Äôappel √† <code class="highlighter-rouge">fork</code>, sur le <code class="highlighter-rouge">if</code>.</p>

<p>Je disais copie <em>presque</em> int√©grale car dans le process p√®re, <code class="highlighter-rouge">fork</code> renvoie le PID du fils, et dans le process fils il renvoie 0. Le fils affichera donc ‚ÄúI am the child‚Äù et le p√®re ‚ÄúI am the father of 1234‚Äù.</p>

<p>En extrapolant, on peut voir le <code class="highlighter-rouge">fork</code> comme une <a href="https://fr.wikipedia.org/wiki/Mitose">mitose</a> cellulaire. Avant la mitose on a 1 cellule et apr√®s la mitose on a 2 cellules qui partagent exactement le m√™me ADN (le code).</p>

<h2 id="trace-moi-si-tu-peux">Trace moi si tu peux</h2>

<p>Linux fournit un syscall appel√© <code class="highlighter-rouge">ptrace</code> qui permet d‚Äôimpl√©menter un d√©bugger.</p>

<p>Daur√©navant nous parlerons de <em>tracer</em> (le d√©bugger) et de <em>tracee</em> (le process  √† d√©bugger), c‚Äôest le vocabulaire employ√© dans la page de <code class="highlighter-rouge">man</code> de <code class="highlighter-rouge">ptrace</code>.</p>

<p>Le <em>tracee</em> fait appel √† la commande <code class="highlighter-rouge">TRACEME</code> pour signaler qu‚Äôil souhaite √™tre trac√© par son p√®re. Dans ce mode, le process peut √™tre dans deux √©tats possibles. Soit il est actif, dans l‚Äô√©tat <code class="highlighter-rouge">RUNNING</code>, soit il est inactif, dans l‚Äô√©tat <code class="highlighter-rouge">STOPPED</code>.</p>

<p>En mode <code class="highlighter-rouge">TRACEME</code>, le <em>tracee</em> passe √† l‚Äô√©tat <code class="highlighter-rouge">STOPPED</code> quand il re√ßoit <strong><em>n‚Äôimporte quel signal</em></strong>.</p>

<p>Le <em>tracee</em> passe √† l‚Äô√©tat <code class="highlighter-rouge">RUNNING</code> quand le p√®re lance la commande <code class="highlighter-rouge">ptrace</code> <code class="highlighter-rouge">CONT</code> (continue).</p>

<p>Le code suivant illustre ce principe :</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_TRACEME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">child</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"I am about to get STOPPED</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
        <span class="n">kill</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"I am RUNNING again</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Waiting for the child to stop</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
        <span class="n">waitpid</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"The tracee is stopped</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_CONT</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="c1">// wait for the child to exit</span>
        <span class="n">waitpid</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Le <em>tracee</em> r√©cup√®re son pid avec la fonction <code class="highlighter-rouge">getpid</code> et s‚Äôenvoie un signal SIGUSR1 via <code class="highlighter-rouge">kill</code>. Notons que <code class="highlighter-rouge">kill</code> est un <em>syscall</em> qui permet d‚Äôenvoyer des signaux √† un process. <code class="highlighter-rouge">kill</code> prend un PID comme premier param√®tre. Le second param√®tre est le signal √† envoyer. On ne peut pas accompager des donn√©es suppl√©mentaires √† un signal. A la r√©ception de ce signal, le <em>tracee</em> passe √† l‚Äô√©tat <code class="highlighter-rouge">STOPPED</code> car il est en mode <code class="highlighter-rouge">TRACEME</code>.</p>

<p>Le <em>tracer</em> fait un premier <code class="highlighter-rouge">waitpid</code>. <code class="highlighter-rouge">waitpid</code> permet d‚Äôattendre un changement d‚Äô√©tat de son processus fils. Ici, il attend que son fils passe √† l‚Äô√©tat <code class="highlighter-rouge">STOPPED</code>. Notons que <code class="highlighter-rouge">wait</code> est un <em>syscall</em> √©galement.</p>

<p>Une fois que <code class="highlighter-rouge">wait</code> redonne la main, le <em>tracer</em> utilise <code class="highlighter-rouge">PTRACE_CONT</code> pour que le <em>tracee</em> repasse √† l‚Äô√©tat <code class="highlighter-rouge">RUNNING</code> et continue de s‚Äôex√©cuter.</p>

<p>Le p√®re fait un ultime <code class="highlighter-rouge">wait</code>. C‚Äôest un peu hors propos mais cela permet au <em>tracee</em> de terminer proprement son ex√©cution, sans rester √† l‚Äô√©tat zombie.</p>

<p>Nous venons d‚Äôillustrer le m√©canisme de signaux et de commandes <code class="highlighter-rouge">ptrace</code> qui permettent de changer l‚Äô√©tat (<code class="highlighter-rouge">RUNNING</code> / <code class="highlighter-rouge">STOPPED</code>) du <em>tracee</em>.</p>

<h2 id="tra√ßons">Tra√ßons</h2>

<p>Lorsque le <em>tracee</em> est √† l‚Äô√©tat <code class="highlighter-rouge">STOPPED</code>, <code class="highlighter-rouge">ptrace</code> fournit au <em>tracer</em> des commandes qui permettent de l‚Äôinspecter et de l‚Äôex√©cuter pas √† pas.</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">PEEKUSER</code> permet d‚Äôinspecter les registres du CPU. Les valeurs de registre ne sont pas lues en live depuis le CPU. En fait, quand le kernel stoppe le tracee il enregistre le contexte du processus, dont les registres, afin que ce dernier puisse reprendre son ex√©cution plus tard, comme si de rien n‚Äô√©tait. Les valeurs renvoy√©es par <code class="highlighter-rouge">ptrace</code> sont issues de cet enregistrement.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">PEEKTEXT</code> permet d‚Äôexaminer la m√©moire.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">SINGLESTEP</code> ex√©cute l‚Äôinstruction point√©e par le registre <code class="highlighter-rouge">RIP</code> et repasse
le <em>tracee</em> √† l‚Äô√©tat <code class="highlighter-rouge">STOPPED</code>.</p>
  </li>
</ul>

<p>Le fonctionnement de ces deux commandes est illustr√© par le code suivant.
Il s‚Äôagit de compter le nombre d‚Äô<a href="https://en.wikipedia.org/wiki/Branch_%28computer_science%29#Examples">embranchement</a> sur lequel est pass√© le <em>tracee</em>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">fizzbuzz</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">fizz</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">fizz</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Fizz"</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">buzz</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">buzz</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Buzz"</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fizz</span><span class="o">||</span><span class="n">buzz</span><span class="p">))</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">", "</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">waitchild</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">WIFSTOPPED</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">WIFEXITED</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d raised an unexpected status %d"</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">trace</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">child</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">instruction</span><span class="p">,</span> <span class="n">opcode1</span><span class="p">,</span> <span class="n">opcode2</span><span class="p">,</span> <span class="n">ip</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">jmps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="n">ip</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKUSER</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">RIP</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">instruction</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKTEXT</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">opcode1</span> <span class="o">=</span> <span class="n">instruction</span> <span class="o">&amp;</span> <span class="mh">0x00000000000000FF</span><span class="p">;</span>
    <span class="n">opcode2</span> <span class="o">=</span> <span class="p">(</span><span class="n">instruction</span> <span class="o">&amp;</span> <span class="mh">0x000000000000FF00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
    <span class="k">if</span><span class="p">((</span><span class="n">opcode1</span> <span class="o">&gt;=</span> <span class="mh">0x70</span> <span class="o">&amp;&amp;</span> <span class="n">opcode1</span> <span class="o">&lt;=</span> <span class="mh">0x7F</span><span class="p">)</span> <span class="o">||</span>
       <span class="p">(</span><span class="n">opcode1</span> <span class="o">==</span> <span class="mh">0x0F</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">opcode2</span> <span class="o">&gt;=</span> <span class="mh">0x83</span> <span class="o">&amp;&amp;</span> <span class="n">opcode2</span> <span class="o">&lt;=</span> <span class="mh">0x87</span><span class="p">)))</span> <span class="p">{</span>
         <span class="n">jmps</span> <span class="o">=</span> <span class="n">jmps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SINGLESTEP</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">waitchild</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">=&gt; There are %lu jumps</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">jmps</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">instruction</span><span class="p">;</span>
    <span class="n">pid_t</span> <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_TRACEME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">child</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
        <span class="n">kill</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>
        <span class="n">fizzbuzz</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// wait for the child to stop</span>
        <span class="n">waitchild</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
        <span class="n">trace</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Le fichier <a href="https://gist.github.com/jprudent/437338b32a54bc37d232f5430ee42f87">source complet</a>.</p>

<p>A l‚Äôex√©cution on a :</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FizzBuzz, 1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16, 17, Fizz, 19, Buzz, Fizz, 22, 23, Fizz, Buzz, 26, Fizz, 28, 29, FizzBuzz, 31, 32, Fizz, 34, Buzz, Fizz, 37, 38, Fizz, Buzz, 41, Fizz, 43, 44, FizzBuzz, 46, 47, Fizz, 49, Buzz, Fizz, 52, 53, Fizz, Buzz, 56, Fizz, 58, 59, FizzBuzz, 61, 62, Fizz, 64, Buzz, Fizz, 67, 68, Fizz, Buzz, 71, Fizz, 73, 74, FizzBuzz, 76, 77, Fizz, 79, Buzz, Fizz, 82, 83, Fizz, Buzz, 86, Fizz, 88, 89, FizzBuzz, 91, 92, Fizz, 94, Buzz, Fizz, 97, 98, Fizz,
=&gt; There are 23037 jumps
</code></pre></div></div>

<p>Plusieurs ex√©cutions du programme retournent toujours le m√™me nombre, ce qui est assez rassurant.</p>

<p>D√©taillons le programme :</p>

<p>La fonction <code class="highlighter-rouge">main</code> reprend le m√™me sch√©ma que les exemples pr√©c√©dents :</p>

<ol>
  <li>
    <p><code class="highlighter-rouge">fork</code> du process</p>
  </li>
  <li>
    <p>le <em>tracee</em> se met en mode <code class="highlighter-rouge">TRACEME</code> et passe √† l‚Äô√©tat <code class="highlighter-rouge">STOPPED</code> en s‚Äôenvoyant n‚Äôimporte quel signal, puis ex√©cutera <code class="highlighter-rouge">fizzbuzz</code> quand il passera √† l‚Äô√©tat <code class="highlighter-rouge">RUNNING</code>.</p>
  </li>
  <li>
    <p>Le <em>tracer</em> attend que le <em>tracee</em> passe √† l‚Äô√©tat <code class="highlighter-rouge">STOPPED</code> puis ex√©cute <code class="highlighter-rouge">trace</code></p>
  </li>
</ol>

<p><code class="highlighter-rouge">fizzbuzz</code> est une simple fonction qui impl√©mente le c√©l√®bre <a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a>. C‚Äôest cette fonction qui sera audit√©e par le <em>tracer</em>.</p>

<p><code class="highlighter-rouge">waitchild</code> encapsule un appel √† <code class="highlighter-rouge">waitpid</code>. Si le <em>tracee</em> passe √† l‚Äô√©tat <code class="highlighter-rouge">STOPPED</code>, elle renvoie 0. Et si le <em>tracee</em> passe √† l‚Äô√©tat <code class="highlighter-rouge">TERMINATED</code>, elle renvoie 1.</p>

<p><code class="highlighter-rouge">trace</code> est une boucle dont la condition d‚Äôarr√™t est le <em>tracee</em> qui passe √† l‚Äô√©tat <code class="highlighter-rouge">TERMINATED</code>. Dans cette boucle, le <em>tracer</em> :</p>

<ol>
  <li>
    <p>Utilise la commande <code class="highlighter-rouge">PEEKUSER</code> afin de r√©cup√©rer l‚Äôadresse de l‚Äôinstruction courante stock√©e dans le registre <code class="highlighter-rouge">RIP</code>. <code class="highlighter-rouge">PEEKUSER</code> permet d‚Äôinspecter les registres du CPU.</p>
  </li>
  <li>
    <p>Lit en m√©moire, √† l‚Äôadresse stock√©e dans <code class="highlighter-rouge">RIP</code>, l‚Äôinstruction sur laquelle le <em>tracee</em> est arr√™t√©, via la commande <code class="highlighter-rouge">PEEKTEXT</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">PEEKTEXT</code> √©crit les octets en m√©moire dans un <code class="highlighter-rouge">long</code> de 8 octets. Notons que l‚Äôarchi x86 est en <a href="https://en.wikipedia.org/wiki/Endianness">little endian</a>, cela signifie que l‚Äôoctet √† l‚Äôadresse point√©e par <code class="highlighter-rouge">RIP</code> est r√©cup√©r√© dans l‚Äôoctet de poids de plus faible du <code class="highlighter-rouge">long</code>. D‚Äôo√π les calculs binaires pour r√©cup√©rer les deux premiers octets point√©s par <code class="highlighter-rouge">RIP</code>.</p>
  </li>
  <li>
    <p>On v√©rifie si l‚Äôinstruction correspond √† une instruction de <a href="https://en.wikipedia.org/wiki/X86_instruction_listings#Original_8086.2F8088_instructions">saut conditionnel</a> (instructions Jcc), auquel cas, on incr√©mente la variable <code class="highlighter-rouge">jmps</code>.</p>
  </li>
  <li>
    <p>On ex√©cute la commande <code class="highlighter-rouge">SINGLESTEP</code> qui ex√©cute <strong><em>une seule</em></strong> instruction du <em>tracee</em> et lui envoie un signal <code class="highlighter-rouge">SIGTRAP</code> pour qu‚Äôil passe imm√©diatement √† l‚Äô√©tat <code class="highlighter-rouge">STOPPED</code>.</p>
  </li>
  <li>
    <p>Apr√®s l‚Äôex√©cution de la boucle, on affiche le r√©sultat.</p>
  </li>
</ol>

<p><em>23000</em> sauts conditionnels est assez hallucinant, cela en fait 2300 par it√©ration. <code class="highlighter-rouge">fizzbuzz</code> est assez simple, mais je pense que <code class="highlighter-rouge">printf</code> doit √™tre assez compliqu√© et faire monter l‚Äôaddition.</p>

<h2 id="tracer-nimporte-quoi">Tracer n‚Äôimporte quoi</h2>

<p>Jusqu‚Äôici, le <em>tracee</em> √©tait un process bien connu, que nous avions cod√© nous m√™me. Ce que nous aimerions, c‚Äôest tracer n‚Äôimporte quel programme.</p>

<p>Le <em>syscall</em> <code class="highlighter-rouge">excecve</code> permet de remplacer l‚Äôimage du process appelant par un autre. A l‚Äôissu du <em>syscall</em> <code class="highlighter-rouge">execve</code>, le process n‚Äôa plus rien √† voir avec le code d‚Äôorigine, il est compl√®tement remplac√© par le programme pass√© √† <code class="highlighter-rouge">execve</code>. D‚Äôailleurs, il n‚Äôy a aucun moyen de r√©cup√©rer le r√©sultat d‚Äô<code class="highlighter-rouge">execve</code>.</p>

<p><code class="highlighter-rouge">execve</code> a 3 param√®tres :</p>
<ul>
  <li>le chemin du programme</li>
  <li>les arguments √† passer au programme</li>
  <li>les variables d‚Äôenvironnement √† passer au programme</li>
</ul>

<p>Une subtilit√© d‚Äô<code class="highlighter-rouge">execve</code> int√©ressante dans notre cas, est qu‚Äôun signal <code class="highlighter-rouge">SIGTRAP</code> est automatiquement envoy√© apr√®s l‚Äôex√©cution d‚Äô<code class="highlighter-rouge">execve</code> si le process est en mode <code class="highlighter-rouge">TRACEME</code>. Ce qui siginifie que l‚Äôon peut se passer d‚Äôenvoyer manuellement un signal dans le <em>tracee</em>. Lorsque <code class="highlighter-rouge">waitpid</code> donne la main au <em>tracer</em>, l‚Äôimage du <em>tracee</em> a √©t√© remplac√©e par celle du programme pass√© en param√®tre d‚Äô<code class="highlighter-rouge">execve</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">waitchild</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">WIFSTOPPED</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">WIFEXITED</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d raised an unexpected status %d"</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">trace</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">child</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">instruction</span><span class="p">,</span> <span class="n">opcode1</span><span class="p">,</span> <span class="n">opcode2</span><span class="p">,</span> <span class="n">ip</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">jmps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="n">ip</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKUSER</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">RIP</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">instruction</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKTEXT</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">opcode1</span> <span class="o">=</span> <span class="n">instruction</span> <span class="o">&amp;</span> <span class="mh">0x00000000000000FF</span><span class="p">;</span>
    <span class="n">opcode2</span> <span class="o">=</span> <span class="p">(</span><span class="n">instruction</span> <span class="o">&amp;</span> <span class="mh">0x000000000000FF00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
    <span class="k">if</span><span class="p">((</span><span class="n">opcode1</span> <span class="o">&gt;=</span> <span class="mh">0x70</span> <span class="o">&amp;&amp;</span> <span class="n">opcode1</span> <span class="o">&lt;=</span> <span class="mh">0x7F</span><span class="p">)</span> <span class="o">||</span>
       <span class="p">(</span><span class="n">opcode1</span> <span class="o">==</span> <span class="mh">0x0F</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">opcode2</span> <span class="o">&gt;=</span> <span class="mh">0x83</span> <span class="o">&amp;&amp;</span> <span class="n">opcode2</span> <span class="o">&lt;=</span> <span class="mh">0x87</span><span class="p">)))</span> <span class="p">{</span>
         <span class="n">jmps</span> <span class="o">=</span> <span class="n">jmps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SINGLESTEP</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">waitchild</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">=&gt; There are %lu jumps</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">jmps</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">instruction</span><span class="p">;</span>
    <span class="n">pid_t</span> <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_TRACEME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">execve</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">argv</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// wait for the child to stop</span>
        <span class="n">waitchild</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
        <span class="n">trace</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Le <a href="https://gist.github.com/jprudent/bdcafa9622784c72cf95839a0fcf55f7">source complet</a>.</p>

<p><code class="highlighter-rouge">waitpid</code> et <code class="highlighter-rouge">trace</code> n‚Äôont pas √©t√© modifi√©s, <code class="highlighter-rouge">fizzbuzz</code> a √©t√© supprim√©.</p>

<p><code class="highlighter-rouge">main</code> a subi quelques alt√©rations :</p>

<ol>
  <li>
    <p>Le <em>tracee</em> s‚Äôattend √† ce que soient pass√©s le chemin du programme √† tracer dans <code class="highlighter-rouge">argv[1]</code> et les arguments du programme √† tracer dans <code class="highlighter-rouge">argv[2]</code>, <code class="highlighter-rouge">argv[3]</code>, etc.</p>
  </li>
  <li>
    <p>Le <em>tracee</em> ne s‚Äôenvoie plus de signal lui-m√™me pour passer √† l‚Äô√©tat <code class="highlighter-rouge">STOPPED</code></p>
  </li>
  <li>
    <p>Le <em>tracee</em> appel <code class="highlighter-rouge">execve</code> qui envoie un signal <code class="highlighter-rouge">SIGTRAP</code> implicitement.</p>
  </li>
</ol>

<p>Le code du <em>tracer</em> n‚Äôa absolument pas chang√©.</p>

<p>A l‚Äôex√©cution, cela donne :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./ptrace_ex4 /usr/bin/ls /      
bin   dev  home  lib64	     media  opt   root	sbin  sys  usr
boot  etc  lib	 lost+found  mnt    proc  run	srv   tmp  var
<span class="o">=&gt;</span> There are 44633 jumps
</code></pre></div></div>
<h2 id="breakpoints">Breakpoints</h2>

<p>Jusqu‚Äôici, le <em>tracer</em> se contente de faire quelques calculs pr√©programm√©s. L‚Äôune des fonctionnalit√©s attendue d‚Äôun d√©bugger est de pouvoir poser des points d‚Äôarr√™t √† une adresse particuli√®re.</p>

<p>La th√©orie est simple : il faut que le <em>tracee</em> passe √† l‚Äô√©tat <code class="highlighter-rouge">STOPPED</code> au moment o√π il ex√©cute l‚Äôinstruction √† l‚Äôadresse choisie.</p>

<p>La pratique ressemble √† un gros hack. Le <em>tracer</em> <strong><em>modifie</em></strong> le code du <em>tracee</em> pour qu‚Äô√† l‚Äôadresse du breakpoint le <em>tracee</em> re√ßoive un signal qui le mette √† l‚Äô√©tat <code class="highlighter-rouge">STOPPED</code>.</p>

<p>Rappelez vous, la plus petite instruction assembleur peut faire un seul octet. Il faut donc que le code qui d√©clenche le signal fasse 1 octet afin de ne pas modifier plusieurs instructions.</p>

<p><code class="highlighter-rouge">int 3</code> a pour opcode 0xCC et l√®ve une <em>interruption</em> sp√©cialement cabl√©e dans le kernel pour envoyer un signal <code class="highlighter-rouge">SIGTRAP</code> √† qui la l√®ve.</p>

<p>Pour √©crire dans la m√©moire du <em>tracee</em>, <code class="highlighter-rouge">ptrace</code> fournit la commande <code class="highlighter-rouge">POKETEXT</code>. Nous verrons aussi la commande <code class="highlighter-rouge">POKEUSER</code> qui permet d‚Äô√©crire dans un registre du CPU.</p>

<p>Voici √† quoi ressemble une impl√©mentation de breakpoint.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">waitchild</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">WIFSTOPPED</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">WIFEXITED</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d raised an unexpected status %d"</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">to_ulong</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">strtol</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">readMemoryAt</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">tracee</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKTEXT</span><span class="p">,</span> <span class="n">tracee</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">writeMemoryAt</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">tracee</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">instruction</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKETEXT</span><span class="p">,</span> <span class="n">tracee</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">instruction</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">readRegister</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">tracee</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKUSER</span><span class="p">,</span> <span class="n">tracee</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">reg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">writeRegister</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">tracee</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKEUSER</span><span class="p">,</span> <span class="n">tracee</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">reg</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">setbp</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">tracee</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">original</span> <span class="o">=</span> <span class="n">readMemoryAt</span><span class="p">(</span><span class="n">tracee</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">int3</span> <span class="o">=</span> <span class="p">(</span><span class="n">original</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFFFFFFF00</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x00000000000000CC</span><span class="p">;</span>
    <span class="n">writeMemoryAt</span><span class="p">(</span><span class="n">tracee</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">int3</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Set breakpoint at %lx, new instruction is %lx instead of %lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
          <span class="n">address</span><span class="p">,</span> <span class="n">readMemoryAt</span><span class="p">(</span><span class="n">tracee</span><span class="p">,</span> <span class="n">address</span><span class="p">),</span> <span class="n">original</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">original</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">removebp</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">tracee</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">original</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">previously</span> <span class="o">=</span> <span class="n">readMemoryAt</span><span class="p">(</span><span class="n">tracee</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
  <span class="n">writeMemoryAt</span><span class="p">(</span><span class="n">tracee</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">original</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Unset breakpoint at %lx, new instruction is %lx, instead of %lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
       <span class="n">address</span><span class="p">,</span> <span class="n">readMemoryAt</span><span class="p">(</span><span class="n">tracee</span><span class="p">,</span> <span class="n">address</span><span class="p">),</span> <span class="n">previously</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">showregisters</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">tracee</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"RIP = %lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
        <span class="n">readRegister</span><span class="p">(</span><span class="n">tracee</span><span class="p">,</span> <span class="n">RIP</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">setIp</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">tracee</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">writeRegister</span><span class="p">(</span><span class="n">tracee</span><span class="p">,</span> <span class="n">RIP</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">presskey</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">getchar</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">setbuf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bpAddress</span> <span class="o">=</span> <span class="n">to_ulong</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">pid_t</span> <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_TRACEME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">execve</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">argv</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// wait for the child to stop</span>
        <span class="n">waitchild</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>

        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">originalInstruction</span> <span class="o">=</span> <span class="n">setbp</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">bpAddress</span><span class="p">);</span>
        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_CONT</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

        <span class="k">while</span><span class="p">(</span><span class="n">waitchild</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"Breakpoint hit !</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
          <span class="n">showregisters</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
          <span class="n">presskey</span><span class="p">();</span>

          <span class="n">removebp</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">bpAddress</span><span class="p">,</span> <span class="n">originalInstruction</span><span class="p">);</span>
          <span class="n">setIp</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">bpAddress</span><span class="p">);</span>

          <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SINGLESTEP</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
          <span class="n">waitchild</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>

          <span class="n">setbp</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">bpAddress</span><span class="p">);</span>

          <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_CONT</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>Le <a href="https://gist.github.com/jprudent/f3965b5e9a658d5088c090a9f0aab2b2">source complet</a></p>

<p>Woh! Ca commence √† √™tre gros ! D√©cortiquons tout √ßa.</p>

<p><code class="highlighter-rouge">main</code> suis le m√™me pattern que d‚Äôhabitude: <code class="highlighter-rouge">fork</code>, et <code class="highlighter-rouge">TRACEME</code>, <code class="highlighter-rouge">execve</code> pour le <em>tracee</em>. En revanche le code du <em>tracer</em> a pas mal chang√© :</p>
<ul>
  <li>Comme d‚Äôhabitude, <code class="highlighter-rouge">waitchild</code> attend que le <em>tracee</em> passe √† l‚Äô√©tat <code class="highlighter-rouge">STOPPED</code>.</li>
  <li><code class="highlighter-rouge">setbp</code> pose le point d‚Äôarr√™t √† l‚Äôadresse demand√©e. Concr√™tement, il s‚Äôagit d‚Äôutiliser la commande <code class="highlighter-rouge">POKETEXT</code> pour √©crire l‚Äôopcode 0xCC (<code class="highlighter-rouge">int 3</code>) √† l‚Äôadresse m√©moire du breakpoint. <code class="highlighter-rouge">setbp</code> retourne l‚Äôinstruction originale (tr√®s important!).</li>
  <li>La commande <code class="highlighter-rouge">CONT</code> permet de continuer l‚Äôex√©cution du <em>tracee</em> jusqu‚Äô√† ce qu‚Äôil ex√©cute cette fameuse <code class="highlighter-rouge">int 3</code> et passe √† l‚Äô√©tat <code class="highlighter-rouge">STOPPED</code></li>
  <li>La boucle <code class="highlighter-rouge">while</code> termine quand le <em>tracee</em> passe √† l‚Äô√©tat <code class="highlighter-rouge">TERMINATED</code></li>
  <li>Si on est rentr√© dans la boucle, cela signifie que l‚Äôinstruction <code class="highlighter-rouge">int 3</code> correspondant au breakpoint a √©t√© ex√©cut√©e.</li>
  <li>On affiche quelques registres et on bloque tant que l‚Äôutilisateur n‚Äôa pas press√© Ctrl+D au clavier pour lui laisser le temps de lire.</li>
  <li>A ce moment le registre <em>RIP</em> vaut <code class="highlighter-rouge">bpAddress + 1</code>, car on a ex√©cut√© <code class="highlighter-rouge">int 3</code> qui fait un octet. Si on laisse filer le <em>tracee</em> il n‚Äôex√©cutera jamais l‚Äôinstruction qui √©tait pr√©vue √† l‚Äôadresse <code class="highlighter-rouge">bpAddress</code>. De plus, <code class="highlighter-rouge">bpAddress + 1</code> contient certainement une instruction inintelligible.</li>
  <li>Donc le <em>tracer</em> remet l‚Äôinstruction originale √† l‚Äôadresse <code class="highlighter-rouge">bpAddress</code> via <code class="highlighter-rouge">POKETEXT</code>.</li>
  <li>Puis le <em>tracer</em> <strong><em>rembobine</em></strong> le fil d‚Äôex√©cution du <em>tracee</em> en mettant le registre <em>RIP</em> √† <code class="highlighter-rouge">bpAddress</code> pour qu‚Äôil pointe sur l‚Äôinstruction pr√©vue. Pour cela, on utilise la commande <code class="highlighter-rouge">POKEUSER</code> pour affecter une valeur √† un registre du CPU.</li>
  <li>Avec la commande <code class="highlighter-rouge">SINGLESTEP</code>, le <em>tracer</em> commande au <em>tracee</em> d‚Äôex√©cuter l‚Äôinstruction √† <code class="highlighter-rouge">bpAddress</code>, la fameuse instruction qui avait √©t√© zapp√©e au profit de <code class="highlighter-rouge">int 3</code>.</li>
  <li>Enfin, le <em>tracer</em> <strong><em>repose le breakpoint</em></strong> et laisse filer le <em>tracee</em> jusqu‚Äô√† ce que ce dernier passe √† <code class="highlighter-rouge">TERMINATED</code> ou √† <code class="highlighter-rouge">STOPPED</code> (s‚Äôil r√©ex√©cute <code class="highlighter-rouge">int 3</code> √† l‚Äôadresse <code class="highlighter-rouge">bpAddress</code>)</li>
</ul>

<p>Testons ce nouveau <em>tracer</em> sur le programme <code class="highlighter-rouge">fizzbuzz</code> suivant :</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">fizzbuzz</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">fizz</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">fizz</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Fizz"</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">buzz</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">buzz</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Buzz"</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fizz</span><span class="o">||</span><span class="n">buzz</span><span class="p">))</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">", "</span><span class="p">);</span>
        <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fizzbuzz</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<p>On peut d√©compiler le programme et chercher la fonction <code class="highlighter-rouge">fizzbuzz</code> :</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ objdump -d fizzbuzz | grep -A200 '&lt;fizzbuzz&gt;:' | less

0000000000400576 &lt;fizzbuzz&gt;:
  400576:	55                   	push   %rbp
  400577:	48 89 e5             	mov    %rsp,%rbp
  40057a:	48 83 ec 10          	sub    $0x10,%rsp
  40057e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  400585:	e9 c3 00 00 00       	jmpq   40064d &lt;fizzbuzz+0xd7&gt;
  40058a:	...
  ... BLA BLA FIZZ BUZZ BLA BLA ...
  400649:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  40064d:	83 7d fc 63          	cmpl   $0x63,-0x4(%rbp)
  400651:	0f 8e 33 ff ff ff    	jle    40058a &lt;fizzbuzz+0x14&gt;
  400657:	90                   	nop
  400658:	c9                   	leaveq
  400659:	c3                   	retq   
</code></pre></div></div>

<p>La fonction <code class="highlighter-rouge">fizzbuzz</code> est mapp√©e en m√©moire √† l‚Äôadresse 0x4004e6.</p>

<p>On reconnait notre boucle :</p>

<ol>
  <li>
    <p>en 0x40057e la variable <code class="highlighter-rouge">i</code> est initialis√©e √† 0</p>
  </li>
  <li>
    <p>en 0x400585 on saute en 0x40064d</p>
  </li>
  <li>
    <p>en 0x40064d on compare <code class="highlighter-rouge">i</code> √† 99</p>
  </li>
  <li>
    <p>en 0x400651 si <code class="highlighter-rouge">i</code> &lt;= 99 on entre dans la boucle en 0x40058a, sinon la fonction se termine</p>
  </li>
  <li>
    <p>en 0x400649 qui est la derni√®re instruction de la boucle, <code class="highlighter-rouge">i</code> est incr√©ment√© et retour en 4)</p>
  </li>
</ol>

<p>Lan√ßons <code class="highlighter-rouge">fizzbuzz</code> avec un point d‚Äôarr√™t sur l‚Äôadresse 0x400651 :</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./ptrace_ex5 400651 ./fizzbuzz
Set breakpoint at 400651, new instruction is c990ffffff338ecc instead of c990ffffff338e0f
Breakpoint hit !
RIP = 400652

Unset breakpoint at 400651, new instruction is c990ffffff338e0f, instead of c990ffffff338ecc
Set breakpoint at 400651, new instruction is c990ffffff338ecc instead of c990ffffff338e0f
FizzBuzz, Breakpoint hit ! // On a pass√© la premi√®re it√©ration
RIP = 400652

Unset breakpoint at 400651, new instruction is c990ffffff338e0f, instead of c990ffffff338ecc
Set breakpoint at 400651, new instruction is c990ffffff338ecc instead of c990ffffff338e0f
1, Breakpoint hit ! // 2√®me it√©ration
RIP = 400652

...
</code></pre></div></div>

<p>Apr√®s avoir press√© 100 fois la touche entr√©e, le <em>tracer</em> et le <em>tracee</em> terminent leur ex√©cution sans probl√®me. Ouf!</p>

<p>Cette impl√©mentation des breakpoints est assez extraordinaire je trouve. Elle a l‚Äôavantage de ne pas ralentir le <em>tracee</em> en dehors des moments o√π il est √† l‚Äô√©tat <code class="highlighter-rouge">STOPPED</code>.</p>

<p>Il ne devrait pas √™tre compliqu√© d‚Äôimpl√©menter des breakpoints conditionnels. Je vous laisse faire √ßa chez vous tranquillement.</p>

<h2 id="breakpoints-sans-modifier-le-tracee">Breakpoints sans modifier le <em>tracee</em></h2>

<p>Il est possible d‚Äôimpl√©menter les breakpoints sans devoir modifier le code du <em>tracee</em>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">waitchild</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">WIFSTOPPED</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">WIFEXITED</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d raised an unexpected status %d"</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">to_ulong</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">strtol</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">readRegister</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">tracee</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKUSER</span><span class="p">,</span> <span class="n">tracee</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">reg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">showregisters</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">tracee</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"RIP = %lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
        <span class="n">readRegister</span><span class="p">(</span><span class="n">tracee</span><span class="p">,</span> <span class="n">RIP</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">presskey</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">getchar</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bpAddress</span> <span class="o">=</span> <span class="n">to_ulong</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">pid_t</span> <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rip</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_TRACEME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">execve</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">argv</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// wait for the child to stop</span>
        <span class="n">waitchild</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
        <span class="k">do</span> <span class="p">{</span>
          <span class="n">rip</span> <span class="o">=</span> <span class="n">readRegister</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">RIP</span><span class="p">);</span>
          <span class="k">if</span><span class="p">(</span><span class="n">rip</span> <span class="o">==</span> <span class="n">bpAddress</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">showregisters</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
            <span class="n">presskey</span><span class="p">();</span>
          <span class="p">}</span>
          <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SINGLESTEP</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">waitchild</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Le <a href="https://gist.github.com/jprudent/05d3a2d2ed26e9d1b12a2770ebcdb5f3">source complet</a>.</p>

<p>Seul le code du <em>tracer</em> a chang√©. L‚Äôid√©e est de d√©rouler le <em>tracee</em> uniquement en pas √† pas et de s‚Äôarr√™ter quand <em>RIP</em> vaut l‚Äôadresse du breakpoint.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ./ptrace_ex6 400651 ./fizzbuzz
 RIP = 400651
 FizzBuzz, RIP = 400651
 1, RIP = 400651
 2, RIP = 400651

 ...
</code></pre></div></div>

<p>C‚Äôest extr√™mement simple compar√© √† l‚Äôautre impl√©mentation mais cela ralentit beaucoup trop le <em>tracee</em>. En effet, pour chaque instruction ex√©cut√©e il faut faire 2 <em>syscall</em>:</p>

<ol>
  <li>
    <p><code class="highlighter-rouge">ptrace</code> <code class="highlighter-rouge">SINGLESTEP</code> qui fait passer le <em>tracee</em> de l‚Äô√©tat <code class="highlighter-rouge">STOPPED</code>
√† l‚Äô√©tat <code class="highlighter-rouge">RUNNING</code> √† l‚Äô√©tat <code class="highlighter-rouge">STOPPED</code></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">wait</code> pour attendre que le <em>tracee</em> soit √† l‚Äô√©tat <code class="highlighter-rouge">STOPPED</code></p>
  </li>
</ol>

<p>Sachant, comme nous l‚Äôavons vu, qu‚Äôun <em>syscall</em> passe par une interruption pour redonner la main au kernel, cette m√©thode ne fonctionne en pratique que sur des petits programmes comme <code class="highlighter-rouge">fizzbuzz</code>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>C‚Äô√©tait un bonne aventure ! Avant de m‚Äôy int√©resser, un d√©bugger √©tait un outil magique aux m√©canismes impalpables.</p>

<p>Je connais d√©sormais les rouages d‚Äôun d√©bugger sous Linux. Je pense que pour OSX, on doit avoir quelque chose de tr√®s similaire.</p>

<p>Ecrire cet article me permet de mieux comprendre la <a href="https://www.gnu.org/software/gdb/documentation/">documentation de GDB</a>.</p>

<p>Aussi, j‚Äôai une bien meilleur cartographie des int√©ractions entre un process et le noyau. Je comprends beaucoup mieux pourquoi on dit qu‚Äôun process bloque quand on fait de l‚ÄôI/O, et j‚Äôen comprends le m√©canisme.</p>

<p>Malgr√© le fait que ce ne soit pas vraiment mon domaine de comp√©tence, j‚Äôai de plus en plus envie de faire de la programmation syst√®me. Le langage <a href="https://doc.rust-lang.org/book/">Rust</a> commence s√©rieusement √† me faire de l‚Äôoeil.</p>

<h2 id="aller-plus-loin">Aller plus loin</h2>

<p>Il y a deux commandes <code class="highlighter-rouge">ptrace</code> que je n‚Äôai pas pr√©sent√© :</p>

<ul>
  <li><code class="highlighter-rouge">ATTACH</code> permet de d√©bugger un process existant, donc sans utiliser le m√©canisme de <code class="highlighter-rouge">fork</code></li>
  <li><code class="highlighter-rouge">SYSCALL</code> arr√™te le <em>tracee</em> √† chaque <em>syscall</em>. Cela permet d‚Äôimpl√©menter la commande <code class="highlighter-rouge">strace</code>.</li>
</ul>

<p>Il existe aussi une troisi√®me fa√ßon de poser des breakpoints: <em>hard breakpoints</em>. Ce m√©canisme est impl√©ment√© directement au niveau du CPU via des registres d√©di√©s.</p>

<h2 id="r√©f√©rences">R√©f√©rences</h2>

<p>Cet article n‚Äôest pas tout √† fait original. Ces quelques sources m‚Äôont accompagn√©es. Si le sujet vous a int√©ress√©, je vous en conseille vivement la lecture.</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">man 2 ptrace</code></p>
  </li>
  <li>
    <p>Playing with ptrace <a href="http://www.linuxjournal.com/article/6100">Part I</a>, <a href="http://www.linuxjournal.com/article/6210">Part II</a></p>
  </li>
  <li>
    <p>Nice <a href="https://mikecvet.wordpress.com/2010/08/14/ptrace-tutorial/]">ptrace tutorial</a></p>
  </li>
  <li>
    <p>Why <a href="http://lwn.net/Articles/371501/">ptrace is aweful</a> ?</p>
  </li>
  <li>
    <p>How debuggers work <a href="http://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1">part1</a>,   <a href="http://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints">part2</a>,   <a href="http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information">part3</a>. En plus l‚Äôauteur a mis des r√©f√©rences en bas de ses articles, ce que j‚Äôappr√©cie beaucoup ;)</p>
  </li>
  <li>
    <p>Explication sur l‚Äôimpl√©mentation des <a href="https://www.kernel.org/doc/ols/2009/ols2009-pages-149-158.pdf">hardware breakpoints</a></p>
  </li>
  <li>
    <p>Un autre article sur <a href="http://www.alexonlinux.com/how-debugger-works">le fonctionnement d‚Äôun debugger</a></p>
  </li>
  <li>
    <p><a href="http://mainisusuallyafunction.blogspot.fr/2011/01/implementing-breakpoints-on-x86-linux.html">Impl√©mentation d‚Äôun breakpoint</a></p>
  </li>
</ul>
:ET