I"+<h1 id="dependency-inversion-principle">Dependency Inversion Principle</h1>

<div id="toc-js">
</div>

<h2 id="motivations">Motivations</h2>

<p>En creusant sur DIP je me suis apperçu que je avais à peine effleuré le sujet, que je l’avais mal appliqué et que je confondais plein de choses.</p>

<p>Cet article me permet avant tout de clarifier mes propres connaissances. J’espère qu’il pourra vous être aussi utile.</p>

<h3 id="motivation-1--réflexion-sur-mes-pratiques-de-développement">Motivation 1 : Réflexion sur mes pratiques de développement.</h3>

<p>Je suis arrivé sur le marché du travail en 2006, sur un gros projet en Java. A cette époque, on était en plein boom Spring. L’un des point fort de Java est l’<em>interface</em>, qui est un super moyen d’abstraction. Ajoutons là dessus Spring pour faire de l’injection et de la manipulation de code (AOP, Transactions, …) et les interfaces deviennent indispensables. On crée donc des interfaces à tout va. Cela permet même de tester son code plus facilement !</p>

<p>Aussi les librairies ont beaucoup évoluées et rendent le découpage interface / implémentation dispensable. Spring est capable d’injecter des implémentations sans interface. Mockito est capable de mocker des implémentations aussi bien que des interfaces. La création systématique d’interface est un anti pattern. Ce n’est pas justifié.</p>

<p><strong>Dans quelles circonstances une interface a une valeur ajoutée ?</strong></p>

<h3 id="motivation-2--désambiguïser-les-concepts">Motivation 2 : Désambiguïser les concepts</h3>

<p>J’entends parler de Dependency Inversion Principle, de Dependency Injection et de Inversion of Control. Tout ça semble nécessiter la création d’interface. L’interface permet de découpler le code, de tester facilement et d’utiliser Spring.</p>

<p><strong>Tous ces termes - DIP, DI, IoC - c’est pour les <a href="http://en.wiktionary.org/wiki/enculeur_de_mouches">pinailleurs</a>, c’est la même chose, n’est-ce pas ?</strong></p>

<h3 id="motivation-3--un-devoir-dhistoire">Motivation 3 : Un devoir d’histoire</h3>

<p>En tant que “jeune” développeur, il faut donc comprendre les problèmes du passé pour donner du sens aux pratiques du présent. Le papier de Robert C. Martin, qui a inventé ce terme, date de 1996! 18 ans! Personne n’avait de téléphone portable ! Internet c’était <a href="http://www.internetworldstats.com/emarketing.htm">36 millions d’utilisateurs</a> (3 milliards aujourd’hui) ! Java était en version 1.0 !</p>

<p>Beaucoup de patterns sont historiques. Les langages ont petit à petit simplifié l’usage des patterns allant jusqu’à les inclure carrément dans le langage. L’<em>interface</em> de Java est un outil d’abstraction beaucoup plus simple que le <em>header file</em> et les classes purement abstraites de C++.</p>

<p><strong>DIP est-il une réponse technique à un problème technique de l’époque ?</strong></p>

<h2 id="dependency-invertion-principle">Dependency Invertion Principle</h2>

<h3 id="objectif">Objectif</h3>

<p>Dans son <a href="http://www.objectmentor.com/resources/articles/dip.pdf">article original</a>, Robert Martin définit un code avec avec un mauvais design :</p>

<ol>
  <li>
    <p>Du code <em>rigide</em> : un code difficile à modifier car chaque changement affecte plusieurs parties du system</p>
  </li>
  <li>
    <p>Du code <em>fragile</em> : Quand on fait un changement, on fait une régression sur une partie inattendue du système.</p>
  </li>
  <li>
    <p>Du code <em>immobile</em> : le code a tellement d’adhérence avec l’application qu’il est impossible de l’extraire pour le réutiliser.</p>
  </li>
</ol>

<p>Ce qui rend un code rigide, fragile, et immobile est l’adhérence entre modules. DIP permet de mieux maitriser ces adhérences en appliquant ces deux principes :</p>

<ul>
  <li>
    <p>les modules de haut niveau (qui ont une dépendance), ne doit pas dépendre des modules de bas niveau (la dite dépendance). Les modules doivent dépendre d’une abstraction.</p>
  </li>
  <li>
    <p>les abstractions ne doivent pas faire apparaître les détails d’implémentations. Les détails doivent dépendre des abstractions.</p>
  </li>
</ul>

<h3 id="mise-en-oeuvre">Mise en oeuvre</h3>

<h4 id="couplage">Couplage</h4>

<p>Voici du code couplé :</p>

<p><img src="/images/articles/DIP/0.png" alt="Service-&gt;Persistance" title="Du code couplé" /></p>

<p>Le code de <code class="highlighter-rouge">Service</code> utilise et dépend du code de <code class="highlighter-rouge">Persistance</code>. <code class="highlighter-rouge">Persistance</code> contient tous les détails d’implémentation. Plus un composant est détaillé, plus il est probable qu’il soit soumis à modification. La modification de <code class="highlighter-rouge">Persistance</code> peut impacter <code class="highlighter-rouge">Service</code>. Il faut les découpler.</p>

<h4 id="découplage">Découplage</h4>

<p>On découple <code class="highlighter-rouge">Service</code> et <code class="highlighter-rouge">Persistance</code> en ajoutant une <em>abstraction de Persistance</em> :</p>

<p><img src="/images/articles/DIP/1.png" alt="Service-&gt;Abstraction&lt;-Implementation" title="Du code découplé" /></p>

<p>Wahou, c’est une interface. Mais quelle interface ?</p>

<h4 id="niveau-conceptuel-de-la-dépendance">Niveau conceptuel de la dépendance</h4>

<p>Soit <code class="highlighter-rouge">java.sql.Connection</code> l’abstraction de <code class="highlighter-rouge">Persistance</code>:</p>

<p><img src="/images/articles/DIP/2.png" alt="Service-&gt;Connection&lt;-Persistance" title="Une interface au mauvais niveau" /></p>

<p>Cette interface contient des méthodes comme <code class="highlighter-rouge">close</code> ou encore <code class="highlighter-rouge">createStatement</code> alors que <code class="highlighter-rouge">Service</code> parle de votre métier. Certes <code class="highlighter-rouge">java.sql.Connection</code> permet de se découpler du vendeur de base de données mais le code métier est pollué de détails relatifs à la persistance.
L’interface JDBC ne permet pas de résoudre notre problème particulier, mais de résoudre un problème global : converser avec une base de donnée.</p>

<p>DIP ne se résume pas à une interface. Une interface est une abstraction qui nous aide à écrire du bon code, mais ce n’est pas suffisant. Il faut en plus qu’elle soit au même niveau conceptuel que le code qui en dépend :</p>

<p><img src="/images/articles/DIP/3.png" alt="Service-&gt;Repository&lt;-RepositoryImpl" title="Une interface au bon niveau" /></p>

<p>Pour que DIP fonctionne, les interfaces doivent avoir un niveau d’abstraction approprié aux besoins réels du système. Par exemple on privilégie une interface Repository avec des méthodes propre au domaine versus un CRUD incipide. <code class="highlighter-rouge">Repository</code> contient des méthodes relatives au métier fournit par <code class="highlighter-rouge">Service</code>, comme <code class="highlighter-rouge">findMauvaisPayeurs</code> ou <code class="highlighter-rouge">payerFacture</code>.</p>

<h4 id="inversion-de-la-dépendance">Inversion de la dépendance</h4>

<p>L’interface doit être définie par celui qui l’utilise et doit se retrouver dans le même package, voir module.</p>

<p><img src="/images/articles/DIP/4.png" alt="(Service-&gt;Repository)&lt;-RepositoryImpl" title="Interface fournie" /></p>

<p>La dépendance est inversé car <code class="highlighter-rouge">Service</code> ne dépend plus de <code class="highlighter-rouge">Persistance</code>. Au contraire elle devient fournisseur d’une interface (SPI) à laquelle se conformer. Elle impose un vocabulaire et des fonctionnalités.</p>

<p>DIP permet de dépendre d’un concept plutôt que d’une implémentation. Et les concepts changent rarement une fois qu’ils ont été analysés et établis (voir DDD, BDD) alors que les implémentations sont souvent mouvantes (refactoring, structure de l’entreprise, effet de mode, …).</p>

<p>DIP n’enlève pas la dépendance mais la spécialise et la relocalise.</p>

<p>Le bénéfice est que <code class="highlighter-rouge">Service</code> est réutilisable en l’état si au lieu d’une base de donnée SQL on décide de passer à du NoSQL. <code class="highlighter-rouge">SqlRepository</code> ne contient pas de code stratégique. Elle se cantonne à passer des octets en RAM sur disque dur.</p>

<h2 id="relations-entre-dip-di-et-ioc">Relations entre DIP, DI et IoC</h2>

<p>L’Inversion of Control (IoC) est un style programmatique : <em>Ne nous appelez pas, c’est nous qui vous rappelons</em>. L’exemple classique est le passage d’une callback à un listener d’évênement : “Quand le bouton est cliqué, exécute moi ce code”. L’IoC est mis en oeuvre dans un framework (cadre de travail litéralement) : DOM, Spring …  Ces deux frameworks n’ont pas les mếmes ambitions mais utilisent toutes deux IoC.</p>

<p><a href="http://martinfowler.com/articles/injection.html">“what aspect of control are they inverting?”</a> se demandait Martin Fowler. Dans le cadre de Spring, l’IoC gère la résolution des dépendances, la configuration et le cycle de vie d’un object.</p>

<p>Dependency Injection est une forme d’IoC qui permet d’externaliser le cablage des composants. On dit a Spring : <em>“Quand Service a besoin d’une référence vers Repository, utilise SqlRepository”</em>.</p>

<p>On utilise DI pour résoudre les dépendances dans le cadre de DIP. Mais on pourrait utiliser un <em>Service Locator</em> à la place.</p>

<h2 id="epilogue">Epilogue</h2>

<p>C’est avec un sentiment de honte et de soulagement que j’achève cet article. Honte d’avoir mis autant de temps à maitriser le sujet. Honte de n’y avoir jamais accordé davantage importance. Soulagé de mettre ça une fois pour toute derrière moi.</p>

<p>Et pour répondre à mes questions :</p>

<ul>
  <li>
    <p>Dans le cadre de DIP, la plus value d’une interface est de maitriser une dépendance et rendre un composant réutilisable.</p>
  </li>
  <li>
    <p>IoC définit le sens d’appel du code, DI permet de cabler du code, et DIP donne une forme au code.</p>
  </li>
  <li>
    <p>DIP est un outil pour concevoir une application et n’a rien à voir avec la technologie sous-jacente.</p>
  </li>
</ul>

<h2 id="sur-le-web">Sur le web</h2>

<p>Cet article est notamment inspiré de :</p>

<ul>
  <li>
    <p><a href="http://www.objectmentor.com/resources/articles/dip.pdf">papier original de Robert C. Martin sur DIP</a></p>
  </li>
  <li>
    <p><a href="http://martinfowler.com/articles/dipInTheWild.html">Cet article</a> présente plusieurs usages de DIP.</p>
  </li>
  <li>
    <p><a href="http://aspiringcraftsman.com/2008/12/28/examining-dependency-inversion">Cet article</a> renforce le précédent.</p>
  </li>
</ul>
:ET