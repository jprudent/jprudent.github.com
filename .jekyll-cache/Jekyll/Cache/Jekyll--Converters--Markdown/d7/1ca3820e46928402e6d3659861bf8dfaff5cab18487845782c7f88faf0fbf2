I"ķ<h1 id="les-bons-tuyaux-de-coreasync">Les bons tuyaux de core.async</h1>

<p><a href="http://clojure.org">Clojure</a> est le langage le plus simple et le plus cohérent que je connaisse. Le coeur du langage est très concis et fournit pourtant tous les outils nécessaires à l’écriture efficace de programmes modernes : manipulation de données, et multithreading.</p>

<p><a href="https://github.com/clojure/core.async">core.async</a> est une librairie qui introduit des outils très simples conceptuellement qui offrent des possibilités incroyables. Elle fait partie du projet clojure mais est facultative.
<code class="highlighter-rouge">core.async</code> est similaire à ce que propose <a href="http://golang.org">Go</a> avec ses <a href="http://www.golang-book.com/10/index.htm">goroutines et channels</a>. Ces concepts étant eux-même inspirés de l’algèbre <a href="http://fr.wikipedia.org/wiki/Communicating_sequential_processes">CSP</a>.</p>

<p>L’objectif de cet article est de vous montrer quelques possibilités offertes par <code class="highlighter-rouge">core.async</code> en introduisant petit à petit les concepts. Nous verrons comment <code class="highlighter-rouge">core.async</code> permet de découpler son code en producteur / consommateur d’information, comment elle permet d’encapsuler un traitement dans une unité de travail, comment elle permet de paralléliser son code sans contrainte, et comment elle ouvre les portes à la programmation réactive.</p>

<h4 id="exemples">Exemples</h4>

<p>La plupart des exemples tournent autours du <a href="http://en.wikipedia.org/wiki/Morra_%28game%29">jeu de Morra</a> qui est une espèce de shi-fu-mi antique. Deux joueurs doivent en même temps produire un nombre avec leurs doigts et crier la somme des doigts des deux joueurs. Le gagnant est celui qui a bien deviné la somme.</p>

<p>Pour taper vous-même les exemples dans un repl, les imports suivants sont suffisants :</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="w"> </span><span class="n">clojure.core.async</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">async</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">thread</span><span class="w"> </span><span class="n">chan</span><span class="w"> </span><span class="n">&lt;!!</span><span class="w"> </span><span class="n">&lt;!</span><span class="w"> </span><span class="n">&gt;!!</span><span class="w"> </span><span class="n">&gt;!</span><span class="w"> </span><span class="n">go</span><span class="w"> </span><span class="n">go-loop</span><span class="p">]])</span><span class="w">
</span></code></pre></div></div>

<h4 id="channels">Channels</h4>

<p>L’élément central de core.async est le <em>channel</em>.
Il s’agit d’un tuyau, d’un canal, conceptuellement proche d’une <em>queue</em> dans un outils de messaging.</p>

<p>Un <em>channel</em> se crée simplement :</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">chan</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Un tel <em>channel</em> ne peut contenir qu’une seule valeur. Cela signifie que l’écriture dans ce <em>channel</em> est bloquée tant que personne ne lit la valeur présente.</p>

<p>Un <em>channel</em> peut être <em>bufferisé</em> pour contenir plusieurs valeurs . Ici on crée un <em>channel</em> qui peut contenir 2 valeurs :</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">chan</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Un tel <em>channel</em> permet d’écrire consécutivement 2 valeurs sans être obligé d’attendre que quelqu’un ne lise les valeurs.</p>

<p>Je conseille de travailler avec des <em>channels</em> <em>non bufferisés dans un premier temps</em>. Cela rend le raisonnement et la compréhension du comportement plus aisés.</p>

<p>Un <em>channel</em> est une valeur comme une autre. Ici on l’associe à une <a href="http://clojure.org/vars">Var</a> :</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">player1</span><span class="w"> </span><span class="p">(</span><span class="nf">chan</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>On pourrait donc associer le <em>channel</em> <code class="highlighter-rouge">player1</code> dans une <code class="highlighter-rouge">Map</code> en tant que clé ou valeur par exemple. Et si on est vicieux, on peut même le faire transiter dans un autre <em>channel</em>.</p>

<h2 id="inversion-of-control">Inversion Of Control</h2>

<p>L’<a href="http://martinfowler.com/bliki/InversionOfControl.html">IoC</a>, est un concept assez général dont le but est de casser les dépendances qu’un module a avec un autre. L’<a href="http://fr.wikipedia.org/wiki/Injection_de_d%C3%A9pendances">injection de dépendance</a> permet de faire de l’IOC (voir <a href="https://github.com/google/guice/wiki/GettingStarted">Guice</a>, <a href="http://projects.spring.io/spring-framework/">Spring</a>, …). Mais la programmation évênementiel, dans le navigateur, où l’on <em>bind</em> un évênement à une <em>callback</em> est aussi une forme d’IOC, dans le sens où le flot d’exécution n’est plus programmé séquentiellement. Quand je dis que <code class="highlighter-rouge">core.async</code> permet de faire de l’IOC, c’est plus dans ce sens.</p>

<h3 id="traditionellement">Traditionellement</h3>

<p>Dans les langages fonctionnels, l’IoC par <a href="">injection de dépendance</a> est assez naturelle puisqu’on peut passer des fonctions en paramètre (fonctions de 1er ordre) :</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">print-claim</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">player-claim</span><span class="w"> </span><span class="p">[</span><span class="n">fingers</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="n">handler</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">handler</span><span class="w"> </span><span class="p">[</span><span class="n">fingers</span><span class="w"> </span><span class="n">sum</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="nf">player-claim</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="n">print-claim</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Ceci affiche <code class="highlighter-rouge">5 8</code> dans la console. Le comportement de la fonction <code class="highlighter-rouge">player-claim</code> a été injecté.</p>

<h3 id="avec-coreasync">Avec core.async</h3>

<p>Avec <code class="highlighter-rouge">core.async</code>, on part d’un <em>channel</em> non bufferisé :</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">player1</span><span class="w"> </span><span class="p">(</span><span class="nf">chan</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Pour écrire dans un channel, on utilise la fonction bloquante <code class="highlighter-rouge">&gt;!!</code></p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">&gt;!!</span><span class="w"> </span><span class="n">player1</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="w"> </span><span class="mi">8</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>A ce stade, <code class="highlighter-rouge">player1</code> contient le vecteur <code class="highlighter-rouge">[5 8]</code>. Par contre l’exécution du programme est bloquée jusqu’à ce que la valeur du <em>channel</em> soit lue. Il existe bien une opération de lecture <code class="highlighter-rouge">&lt;!!</code>, mais puisqu’on est bloqué, on ne pourra jamais l’exécuter dans le même thread. Comment faire ?</p>

<p>La solution est d’effectuer l’opération de lecture dans une autre unité d’exécution, soit un thread.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">thread</span><span class="w">
  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="w"> </span><span class="s">"player 1 moves : "</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">&lt;!!</span><span class="w"> </span><span class="n">player1</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>La macro <code class="highlighter-rouge">thread</code> permet de créer … un thread. Ce thread boucle indéfiniment. A chaque itération de boucle il affiche la valeur
contenue dans le <em>channel</em> <code class="highlighter-rouge">player1</code>. Et dans un REPL ça donne :</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user=&gt; (def player1 (chan))
#'user/player1

user=&gt; (thread (loop [m "player 1 moves : "] (println m) (recur (&lt;!! player1))))
player 1 moves :
#

user=&gt; (&gt;!! player1 [5 8])
true
[5 8]

user=&gt; (&gt;!! player1 [1 2])
[1 2]
true

user=&gt; (&gt;!! player1 [1 3])
[1 3]
true
</code></pre></div></div>

<p>On a un thread qui produit les mouvements du joueur 1 sans savoir ce qui en sera fait. Et on a un autre thread qui reçoit les mouvements et les affiche. Au runtime nous avons nous même fait l’association producteur / consommateur. Cela correspond à la notion d’<a href="http://martinfowler.com/bliki/InversionOfControl.html">Invertion of Control</a>, si ce n’est qu’on a codé notre propre framework et utilisant un <em>channel</em> pour faire la colle entre les composants.</p>

<p>La version du code utilisant <code class="highlighter-rouge">core.async</code> va plus loin en rendant le code asynchrone. A chaque composant sa spécialisation, à chaque composant son unité d’exécution.</p>

<h2 id="modèle-dacteur">Modèle d’acteur</h2>

<p><a href="http://fr.wikipedia.org/wiki/Mod%C3%A8le_d%27acteur">Wikipedia</a> définit le modèle d’acteur ainsi :</p>

<blockquote>
  <p>Un acteur est une entité capable de calculer, qui, en réponse à un message reçu, peut parallèlement :</p>
</blockquote>

<blockquote>
  <p>1) envoyer un nombre fini de messages à d’autres acteurs ;</p>
</blockquote>

<blockquote>
  <p>2) créer un nombre fini de nouveaux acteurs ;</p>
</blockquote>

<blockquote>
  <p>3) spécifier le comportement à avoir lors de la prochaine réception de messages.</p>
</blockquote>

<p>Etudions ce petit programme :</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">player1</span><span class="w"> </span><span class="p">(</span><span class="nf">chan</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">player2</span><span class="w"> </span><span class="p">(</span><span class="nf">chan</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">(</span><span class="nf">chan</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">thread</span><span class="w">
  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">scores</span><span class="w"> </span><span class="p">{</span><span class="no">:player1</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="no">:player2</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="no">:draw</span><span class="w"> </span><span class="mi">0</span><span class="p">}]</span><span class="w">
   </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Scores : "</span><span class="w"> </span><span class="n">scores</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="nf">recur</span><span class="w">
    </span><span class="p">(</span><span class="nf">update-in</span><span class="w"> </span><span class="n">scores</span><span class="w"> </span><span class="p">[(</span><span class="nf">&lt;!!</span><span class="w"> </span><span class="n">result</span><span class="p">)]</span><span class="w"> </span><span class="nb">inc</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">winner</span><span class="w"> </span><span class="p">[</span><span class="n">correct-guess</span><span class="w"> </span><span class="n">p1-guess</span><span class="w"> </span><span class="n">p2-guess</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">cond</span><span class="w">
   </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">p1-guess</span><span class="w"> </span><span class="n">p2-guess</span><span class="p">)</span><span class="w"> </span><span class="no">:draw</span><span class="w">
   </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">correct-guess</span><span class="w"> </span><span class="n">p1-guess</span><span class="p">)</span><span class="w"> </span><span class="no">:player1</span><span class="w">
   </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">correct-guess</span><span class="w"> </span><span class="n">p2-guess</span><span class="p">)</span><span class="w"> </span><span class="no">:player2</span><span class="w">
   </span><span class="no">:else</span><span class="w"> </span><span class="no">:draw</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">thread</span><span class="w">
 </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[]</span><span class="w">
   </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="n">p1-fingers</span><span class="w"> </span><span class="n">p1-guess</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">&lt;!!</span><span class="w"> </span><span class="n">player1</span><span class="p">)</span><span class="w">
         </span><span class="p">[</span><span class="n">p2-fingers</span><span class="w"> </span><span class="n">p2-guess</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">&lt;!!</span><span class="w"> </span><span class="n">player2</span><span class="p">)</span><span class="w">
          </span><span class="n">correct-guess</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">p1-fingers</span><span class="w"> </span><span class="n">p2-fingers</span><span class="p">)]</span><span class="w">
     </span><span class="p">(</span><span class="nf">&gt;!!</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">(</span><span class="nf">winner</span><span class="w"> </span><span class="n">correct-guess</span><span class="w"> </span><span class="n">p1-guess</span><span class="w"> </span><span class="n">p2-guess</span><span class="p">))</span><span class="w">
     </span><span class="p">(</span><span class="nf">recur</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>On a 2 unités d’exécution. La première est dédiée à l’affichage du score. A chaque fois qu’une valeur est présente dans <code class="highlighter-rouge">result</code> la valeur de <code class="highlighter-rouge">scores</code> est mise à jour.</p>

<p>Notons que la valeur actuelle du score est complètement <em>encapsulée</em>. Personne d’autre ne peut connaitre le score.
La valeur du score courant est dépendante de la valeur précédente. Le 3ème point de la définition d’un acteur, <em>spécifier le comportement à avoir lors de la prochaine réception de messages</em>, est bien vérifié.</p>

<p>La seconde unité d’exécution lit tour à tour dans les <em>channel</em> <code class="highlighter-rouge">player1</code> et <code class="highlighter-rouge">player2</code>, détermine un gagnant et écrit le résultat dans <code class="highlighter-rouge">result</code> qui sera relue par notre 1ère unité d’exécution. Le 1er point de la définition d’un acteur, <em>envoyer un nombre fini de messages à d’autres acteurs</em> est vrai.</p>

<p>Concernant le 2ème point de la définition, <em>créer un nombre fini de nouveaux acteurs</em>, je n’ai pas trouvé quelque chose de pertinant pour le démontrer. Cela est néanmoins possible si on remplace le premier acteur par ceci :</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">print-stats</span><span class="w"> </span><span class="p">[</span><span class="n">stats</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">total</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">vals</span><span class="w"> </span><span class="n">stats</span><span class="p">))]</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"wins : "</span><span class="w"> </span><span class="p">(</span><span class="no">:wins</span><span class="w"> </span><span class="n">stats</span><span class="p">)</span><span class="w"> </span><span class="s">"/"</span><span class="w"> </span><span class="n">total</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"draws : "</span><span class="w"> </span><span class="p">(</span><span class="no">:draws</span><span class="w"> </span><span class="n">stats</span><span class="p">)</span><span class="w"> </span><span class="s">"/"</span><span class="w"> </span><span class="n">total</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">run-stats</span><span class="w"> </span><span class="p">[</span><span class="n">channel</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">stats</span><span class="w"> </span><span class="p">{</span><span class="no">:wins</span><span class="w"> </span><span class="mi">0</span><span class="n">,</span><span class="w"> </span><span class="no">:draws</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span><span class="w">
         </span><span class="n">total</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nf">print-stats</span><span class="w"> </span><span class="n">stats</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">recur</span><span class="w">
       </span><span class="p">(</span><span class="nf">update-in</span><span class="w"> </span><span class="n">stats</span><span class="w"> </span><span class="p">[(</span><span class="nf">&lt;!!</span><span class="w"> </span><span class="n">channel</span><span class="p">)]</span><span class="w"> </span><span class="nb">inc</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">total</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="nf">thread</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">stats</span><span class="w"> </span><span class="p">(</span><span class="nf">chan</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">thread</span><span class="w"> </span><span class="p">(</span><span class="nf">run-stats</span><span class="w"> </span><span class="n">stats</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">scores</span><span class="w"> </span><span class="p">{</span><span class="no">:player1</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="no">:player2</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="no">:draw</span><span class="w"> </span><span class="mi">0</span><span class="p">}]</span><span class="w">
        </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Scores : "</span><span class="w"> </span><span class="n">scores</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">winner</span><span class="w"> </span><span class="p">(</span><span class="nf">&lt;!!</span><span class="w"> </span><span class="n">result</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nf">&gt;!!</span><span class="w"> </span><span class="n">stats</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="no">:draw</span><span class="w"> </span><span class="n">winner</span><span class="p">)</span><span class="w"> </span><span class="no">:draw</span><span class="w"> </span><span class="no">:wins</span><span class="p">))</span><span class="w">
        </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">update-in</span><span class="w"> </span><span class="n">scores</span><span class="w"> </span><span class="p">[</span><span class="n">winner</span><span class="p">]</span><span class="w"> </span><span class="nb">inc</span><span class="p">))))))</span><span class="w">
</span></code></pre></div></div>

<p>La présence des deux threads imbriqués indique le lancement d’un acteur par un autre. Le 2ème point de la définition est vérifié.</p>

<p>Je pense qu’on peut appeler chaque thread un acteur, car on vient de voir que cela répond à la définition. Certes ce sont des acteurs très basiques (pas de pattern matching, pas de stratégie de mailbox, pas de priorité de messages, …).
Au pire on peut dire que ce sont des objets, dans le sens où ils encapsulent un état et communiquent par message.</p>

<h2 id="programmation-concurrente-illimitée">Programmation concurrente illimitée</h2>

<p>Dans les précédents exemples nous avons instancié des threads pour consommer les valeurs contenues dans les <em>channels</em>. Chacun de ces threads consistait en une boucle infinie qui bloquait sont exécution jusqu’à ce qu’une valeur soit lisible. Ce modèle est limité par les <a href="http://stackoverflow.com/questions/763579/how-many-threads-can-a-java-vm-support">quelques milliers</a> de threads que l’on peut lancer sur la VM. Sans compter <a href="http://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html">le temps perdu</a> en <a href="http://en.wikipedia.org/wiki/Context_switch">context switch</a>.</p>

<p>Imaginons maintenant que notre plateforme de jeu n’ait pas quelques milliers de threads mais plutôt un centaine de millier.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">dotimes</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="w"> </span><span class="mi">100000</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">c</span><span class="w"> </span><span class="p">(</span><span class="nf">chan</span><span class="p">)]</span><span class="w">
  
    </span><span class="p">(</span><span class="nf">thread</span><span class="w">
      </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[]</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="n">_</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">tv</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">&lt;!!</span><span class="w"> </span><span class="n">c</span><span class="p">)]</span><span class="w">
          </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nf">mod</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="mi">100</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">tv</span><span class="p">)))</span><span class="w">
          </span><span class="p">(</span><span class="nf">recur</span><span class="p">)))</span><span class="w">
          
    </span><span class="p">(</span><span class="nf">thread</span><span class="w">
      </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="p">(</span><span class="nb">iterate</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="mi">1</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nf">&gt;!!</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="w"> </span><span class="n">v</span><span class="p">])))))</span><span class="w">
</span></code></pre></div></div>

<p>Ici on crée 2 threads 100000 fois. Le premier lit dans un channel et affiche le résultat si c’est un multiple de 100. Le second écrit les entiers de 1 à l’infini.</p>

<p>10000 lignes environ s’affichent puis plus rien. Le CPU monte à 100%, la JVM compte 32000 threads et boom, IOException.</p>

<p>Pour pallier ces limitations, <em>core.async</em> offre la possibilité de créer des processus ultra légers, capables de se partager un pool de threads et qui peuvent se mettre en pause sans bloquer le thread d’exécution.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">dotimes</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="w"> </span><span class="mi">100000</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">c</span><span class="w"> </span><span class="p">(</span><span class="nf">chan</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">go</span><span class="w">
      </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[]</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[[</span><span class="n">t</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">tv</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">&lt;!</span><span class="w"> </span><span class="n">c</span><span class="p">)]</span><span class="w">
          </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nf">mod</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="mi">100</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">tv</span><span class="p">)))</span><span class="w">
          </span><span class="p">(</span><span class="nf">recur</span><span class="p">)))</span><span class="w">
    </span><span class="p">(</span><span class="nf">go</span><span class="w">
      </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="p">(</span><span class="nb">iterate</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="mi">1</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nf">&gt;!</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="w"> </span><span class="n">v</span><span class="p">])))))</span><span class="w">
</span></code></pre></div></div>

<p>Dans cette version du programme, j’ai remplacé les threads créés par <code class="highlighter-rouge">thread</code> par des processus ultra légers via <code class="highlighter-rouge">go</code> et les appels bloquants <code class="highlighter-rouge">&gt;!!</code> et <code class="highlighter-rouge">&lt;!!</code> par leurs versions non-bloquantes <code class="highlighter-rouge">&gt;!</code> et <code class="highlighter-rouge">&lt;!</code>.</p>

<p>Le programme est stable et régulier : des salves d’informations s’affichent sur la console toutes les 40 secondes environ, les 8 coeurs de mon CPU sont à 40%, la consommation du heap oscille entre 1700 mégas et 160 après GC, et la JVM compte 70 threads.</p>

<p>Nous avons donc réussi à <em>simuler</em> 200000 threads ! J’ai oublié de préciser que <em>ce code peut aussi tourner sur un navigateur</em> … Oui on peut écrire du code asynchrone dans le navigateur sans callbacks (hell).</p>

<h2 id="functional-reactive-programming">Functional Reactive Programming</h2>

<p>Dans un article <a href="http://www.arolla.fr/blog/2014/05/experimentation-de-frp-avec-bacon-js/">précédent</a>, j’avais fait une micro présentation de FRP. Pour rappel, il s’agit d’un style de programmation basé sur la manipulation de flux de valeurs, à base de <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">filter</code>, <code class="highlighter-rouge">zip</code>, <code class="highlighter-rouge">concat</code>, … En bout de chaine de chaque flux, on peut “consommer” les valeurs du flux pour réaliser des effets de bord, un affichage ou une écriture en base par exemple.</p>

<p>Etudions ce bout de code :</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">player1</span><span class="w"> </span><span class="p">(</span><span class="nf">chan</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">player2</span><span class="w"> </span><span class="p">(</span><span class="nf">chan</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">winner</span><span class="w"> </span><span class="p">[</span><span class="n">correct-guess</span><span class="w"> </span><span class="n">p1-guess</span><span class="w"> </span><span class="n">p2-guess</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">cond</span><span class="w">
    </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">p1-guess</span><span class="w"> </span><span class="n">p2-guess</span><span class="p">)</span><span class="w"> </span><span class="no">:draw</span><span class="w">
    </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">correct-guess</span><span class="w"> </span><span class="n">p1-guess</span><span class="p">)</span><span class="w"> </span><span class="no">:player1</span><span class="w">
    </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">correct-guess</span><span class="w"> </span><span class="n">p2-guess</span><span class="p">)</span><span class="w"> </span><span class="no">:player2</span><span class="w">
    </span><span class="no">:else</span><span class="w"> </span><span class="no">:draw</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">process-round</span><span class="w"> </span><span class="p">[[</span><span class="n">p1-fingers</span><span class="w"> </span><span class="n">p1-guess</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">p2-fingers</span><span class="w"> </span><span class="n">p2-guess</span><span class="p">]]</span><span class="w">
  </span><span class="p">(</span><span class="nf">winner</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">p1-fingers</span><span class="w"> </span><span class="n">p2-fingers</span><span class="p">)</span><span class="w"> </span><span class="n">p1-guess</span><span class="w"> </span><span class="n">p2-guess</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">ch-results</span><span class="w"> </span><span class="p">(</span><span class="nf">async/map</span><span class="w"> </span><span class="n">process-round</span><span class="w"> </span><span class="p">[</span><span class="n">player1</span><span class="w"> </span><span class="n">player2</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<p>On commence par définir les deux <em>channels</em> qui contiennent les inputs des deux joueurs.
Ensuite, on a la fonction <code class="highlighter-rouge">winner</code> que nous connaissons déjà. Puis vient la fonction <code class="highlighter-rouge">process-round</code> qui prend les inputs des 2 joueurs et retourne le gagnant.
Enfin, nous créons un nouveau <em>channel</em> référencé par <code class="highlighter-rouge">ch-results</code>. Cependant on le crée via la fonction <code class="highlighter-rouge">map</code>. <code class="highlighter-rouge">map</code> prend en paramètre un vecteur de <em>channels</em> et une fonction. La fonction a autant de paramètres que de <em>channels</em> dans le vecteur. <code class="highlighter-rouge">map</code> crée un <em>channel</em> qui contient le résultat de <code class="highlighter-rouge">f</code> appliquée aux premières valeurs des <em>channels</em> du vecteur.</p>

<p>Si on joue de la manière suivante :</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">&gt;!!</span><span class="w"> </span><span class="n">player1</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">&gt;!!</span><span class="w"> </span><span class="n">player2</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">&gt;!!</span><span class="w"> </span><span class="n">player1</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">&gt;!!</span><span class="w"> </span><span class="n">player1</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<p>Alors <code class="highlighter-rouge">ch-results</code> contiendra <code class="highlighter-rouge">:draw</code>, <code class="highlighter-rouge">:player1</code>.</p>

<p>Poursuivons :</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">async-reduce</span><span class="w"> </span><span class="p">[</span><span class="n">f</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="n">ch-input</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">ch-output</span><span class="w"> </span><span class="p">(</span><span class="nf">chan</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">go-loop</span><span class="w"> </span><span class="p">[</span><span class="n">acc</span><span class="w"> </span><span class="n">init</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nf">&gt;!</span><span class="w"> </span><span class="n">ch-output</span><span class="w"> </span><span class="n">acc</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">f</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="p">(</span><span class="nf">&lt;!</span><span class="w"> </span><span class="n">ch-input</span><span class="p">))))</span><span class="w">
    </span><span class="n">ch-output</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">ch-scores</span><span class="w">
  </span><span class="p">(</span><span class="nf">async-reduce</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">update-in</span><span class="w"> </span><span class="n">%1</span><span class="w"> </span><span class="p">[</span><span class="n">%2</span><span class="p">]</span><span class="w"> </span><span class="nb">inc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="no">:player1</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="no">:player2</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="no">:draw</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span><span class="w"> </span><span class="n">ch-results</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">go</span><span class="w"> </span><span class="p">(</span><span class="nf">while</span><span class="w"> </span><span class="n">true</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Scores : "</span><span class="w"> </span><span class="p">(</span><span class="nf">&lt;!</span><span class="w"> </span><span class="n">ch-scores</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p><code class="highlighter-rouge">async-reduce</code> est une fonction utilitaire qui est similaire à un <code class="highlighter-rouge">reduce</code> classique, sauf qu’au lieu de ne renvoyer qu’une seule valeur, elle renvoie un <em>channel</em> sur lequel elle publie tous les résultats intermédiaires.
Ensuite on crée un nouveau <em>channel</em> <code class="highlighter-rouge">ch-scores</code> via <code class="highlighter-rouge">async-reduce</code> qui contiendra tous les scores sucessifs, au fur et à mesure des parties.
Enfin un <code class="highlighter-rouge">go</code> block consomme <code class="highlighter-rouge">ch-scores</code> pour afficher les scores.</p>

<p>On a mergé, transformé des flux de données pour arriver au résultat attendu. Le side effect est à la fin du programme. Bref, du FRP.</p>

<p>Ce que j’aime avec ce style de programmation, c’est que c’est facilement extensible. Par exemple pour n’afficher que les résultats où un joueur a gagné, il suffit de modifier légèrement le flux de données avec un filtre :</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">ch-non-draw-results</span><span class="w"> </span><span class="p">(</span><span class="nf">async/filter&lt;</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">not=</span><span class="w"> </span><span class="no">:draw</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="n">ch-results</span><span class="w"> </span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">ch-scores</span><span class="w">
  </span><span class="p">(</span><span class="nf">async-reduce</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">update-in</span><span class="w"> </span><span class="n">%1</span><span class="w"> </span><span class="p">[</span><span class="n">%2</span><span class="p">]</span><span class="w"> </span><span class="nb">inc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="no">:player1</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="no">:player2</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span><span class="w"> </span><span class="n">ch-non-draw-results</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Et une séquence de jeu ressemble à ça :</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user=&gt; (&gt;!! player1 [1 2])
true
user=&gt; (&gt;!! player2 [1 2])
true

user=&gt; (&gt;!! player1 [1 2])
true
user=&gt; (&gt;!! player2 [1 3])
true
Scores : {:player2 0, :player1 1}

user=&gt; (&gt;!! player1 [1 2])
true
user=&gt; (&gt;!! player2 [1 3])
true
Scores : {:player2 0, :player1 2}
</code></pre></div></div>

<h2 id="les-mots-de-la-fin">Les mots de la fin</h2>

<p>On a passé en revue 4 bénéfices que l’on peut tirer de <code class="highlighter-rouge">core.async</code> :</p>
<ul>
  <li>Invertion Of Control</li>
  <li>Modèle d’acteur</li>
  <li>Programmation concurrente illimitée</li>
  <li>Functional Reactive Programming</li>
</ul>

<p>On a réussi à implémenter tout ça avec une API super simple qui peut se résumer à :</p>
<ul>
  <li>un tuyau</li>
  <li>des processus légers pour lire et écrire le tuyau</li>
</ul>

<p>Comme nous l’avons vu, nous n’avons pas affaire à la lourdeur d’un framework qui impose une façon de faire, mais une librairie apportant les briques nécessaires pour faire du <em>sur mesure</em>.</p>

<p>Cette librairie existe aussi en <a href="https://github.com/clojure/clojurescript">ClojureScript</a>. Cela vous permet d’écrire du code asynchrone sans callbacks dans le navigateur.</p>

<p>Bienvenue dans le futur.</p>

<h2 id="ressources">Ressources</h2>

<p><a href="http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html">Rationale</a> : explication des concepts fondamentaux et leur origine.</p>

<p><a href="http://clojure.github.io/core.async/">API</a></p>

<p><a href="https://github.com/clojure/core.async/blob/master/examples/walkthrough.clj">Walk throught</a> Des exemples à taper dans la REPL.</p>

<p><a href="http://en.wikipedia.org/wiki/Morra_%28game%29">Le jeu de Morra</a> : le petit jeu implémenté dans cet article.</p>
:ET